_Explicit the differences between the version 1.0 and the version 1.1_

Summary :

<wiki:toc max_depth="4" />



= Difference between the version 1.0 and the version 1.1 =



*List of main changes between the two versions : *

 * Additions of many tests / exception handling limits validation crashes of an architecture and increase the feedback.

 * Modification of CLACS and GCLACS meta-metamodeles. (In the following of this page, the meta-metamodels will be nominated by metamodels).

 * Modification of GMF models (gmfgraph, gmftool, gmfmap, gmfgen) 

 * Improvement of graphic interface (Custom figure) 

 * Graphic and implementation addition of the arguments(Arg) and the body (Body), return type (returnedType) for the services.
 
 * Graphic and implementation addition of used services (UsedService) and its arguments values(listArgService) for the bindings. 

 * Integration and analyses of OCL constraints (with and without arguments)basing on the modeled component architecture 

== Détails ==


_Nous développerons ci-après les modifications apportées aux deux métamodèles du projet. Ceux-ci correspondent au noyau central du projet. Ce sont eux qui vont définir les règles du langage CLACS, les éléments graphiques et leurs possibilités de placement, leurs relations etc.
Nous évoquerons aussi les ajouts effectués aux modèles gmf (gmfgraph, gmfmap, gmftool etc.) qui définissent l'environnement graphique.
Nous parlerons enfin des modifications apportées au code source._

===Comparatif ancien / nouveau métamodèle CLACS===


====Ancien métamodèle CLACS====
[http://clacs.googlecode.com/files/CLACS2.png]
====Nouveau métamodèle CLACS====
[http://clacs.googlecode.com/files/CLACS23-07-092.png]

Le descripteur de composant(ComponentDescriptor), qui était l'élément central de l'ancien métamodèle a laissé place à l'instance de composant (ComponentInstance). Cela permet de voir un composant modélisé comme étant de base une instance d'un composant (décrivant le descripteur de ce composant). 

Manipuler une instance autorise la génération d'une instance ou d'un descripteur de composant aisément. Ainsi, les ports, interfaces et binding de retrouvent "inclus" dans l'instance de composant. La notion de descripteur a été encapsulé, de manière a simplifier la modélisation, elle reste bien-sûr présente en interne. 

Les notions de corps de service (Body), arguments des services (Arg) ainsi que les services utilisés par un binding (UsedService) étaient déjà présentes dans ce métamodèle, mais non implémentées. 

On peut voir que les notions d'AssemblyBinding et de DelegationBinding ont été ajouté, mais qu'elle ne sont pas pour le moment connectés au binding. 

L'ancien BindingKind laissera alors place aux A_BindingKind et D_BindingKind. (ces modifications induiront une modification du système d'interprétation des contraintes OCL). 
Ils permettront d'effectuer des associations de contraintes. Par exemple, si deux composants contraintes sont connectés entre eux par un binding OR et que ceux-là sont reliés à un composant métier, ce dernier devra satisfaire l'une ou l'autre des contraintes. 

===Comparatif ancien/ nouveau métamodèle GCLACS===
 
====Ancien métamodèle GCLACS====
[http://clacs.googlecode.com/files/GCLACS2.png]
====Nouveau métamodèle GCLACS====
[http://clacs.googlecode.com/files/GCLACS23-07-092.png]

Toutes les modifications apportées au métamodèle CLACS ont eu des répercutions sur ce métamodèle. 

Les éléments suivants ont été retravaillés : 

 * De la même manière que pour le métamodèle CLACS, le métamodèle est centralisé autour de la notion d'instance de composant (ComponentInstance) 

 * Comme pour le métamodèle CLACS, les services disposent désormais d'un corps (Body), d'un ensemble d'arguments (Arg) et d'un type de retour (returnedType)
 
 * Les binding disposent désormais d'un nom (pour pouvoir être identifié dans les contraintes OCL). Ils possèdent de plus un service utilisé (usedServiceName) et de la liste de ses paramètres (usedServiceArgs). 
 
===Modifications gmfgraph===

Comme on peut le voir sur cette nouvelle version du gmfgraph, le noeud ComponentDescriptor et sa représentation associée a été retiré. 

La figure du ComponentInstance se voit doté d'un label supplémentaire, permettant de renseigner le nom du descripteur qui lui est lié. 

Les nœuds Arg et Body font leur apparition et sont décrits par des "Custom Figure", figure que l'on va créer de tout pièce en créant une nouvelle classe basée sur la classe générique "Shape". 

Un "Compartment" BodyArgsCompartments a été ajouté. Il appartiendra à l'élément Service permettant le stockage des Arg et Body. 

[http://clacs.googlecode.com/files/gmfgraph23-07-09.png]

===Modifications gmfmap=== 

La hiérarchie des éléments a été totalement revue. Elle a donc été adaptée pour ne plus contenir les descripteurs de composants, et s'est étendue pour gérer les nouveaux concepts comme le corps d'un service ou ses arguments. 

[http://clacs.googlecode.com/files/gmfmap23-07-09.png]

===Modifications gmftool=== 

Ce modèle décrit le contenu de la palette servant à modéliser les éléments (Composant, Ports, Services etc.) dans l'environnement GCLACS. 

Il a donc subit peu de changement : la disparition de l'outil ComponentDescriptor, et l'apparition des outils Body et Arg. 

[http://clacs.googlecode.com/files/gmftool23-07-09.png]

===Modification au niveau du code source===

 * Les classes régissant la gestion des items du menu du plugin GCLACS ont été retravaillées pour correspondre aux nouveaux modèles. 
 
 * Le langage de spécification CLACS et l'environnement GCLACS ayant subit des modifications, les opérations résultantes ont aussi été retravaillées.

Un nouveau Plugin va gérer les contraintes OCL incluses dans les définitions des services des composants. Ce Plugin gère à l'heure actuelle les contraintes OCL avec et sans paramètre.
Le contexte du composant contrainte est propagé dans le cas où ce composant serait connecté à un ou plusieurs autres composants contraintes. 
Le premier composant non contrainte trouvé sera le contexte.

Dans l'exemple ci-dessous (modélisé avec GCLACS), Cst et Cst2 sont deux composants contraintes, et Comp un composant métier.
Cst va apporter une contrainte sur son contexte. Mais Cst étant connecté à Cst2 qui est lui aussi un composant contrainte, le contexte va se propager à Comp (vu que Cst2 est lui connecté à Comp) :

[http://clacs.googlecode.com/files/exemplePropagationContexte.png]

Les interprétations tirant partie de binding plus évolués (AND, OR, XOR etc.) pour combiner les contraintes ne sont pas encore implémentées. 